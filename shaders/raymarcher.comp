#version 450

layout (binding = 0) uniform UniformBufferObject {
    vec3 position;
    vec3 viewDirection;
    float FOV;
} ubo;

layout (binding = 1, rgba8) uniform writeonly image2D outputImage;

struct OctreeNode {
    int childrenIndex;
    int value;
    bool homogenous;
    int minX, minY, maxX, maxY;
    vec3 END;
    //int childrenIndex;
    //int value;
    //bool homogenous;
    //int minX, minY, maxX, maxY;
};

layout(std140, binding = 2) readonly buffer Octree{
    OctreeNode nodes[5];
} octree;

layout (local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

struct Ray {
    vec3 origin;
    vec3 direction;
};

float CANVAS_DISTANCE = 1;
vec3 WORLD_UP = vec3(0.0, 0.0, 1.0);
Ray createRay() {
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(imageSize(outputImage))*2-1;
	vec3 uvRight = normalize(cross(ubo.viewDirection, WORLD_UP));
	vec3 uvDown = normalize(cross(ubo.viewDirection, uvRight));
	vec3 toCanvas = ubo.viewDirection * CANVAS_DISTANCE;
	vec2 canvasSize = imageSize(outputImage);
	vec3 rayPosition = ubo.position + toCanvas + (uvRight * uv.x) + (uvDown * uv.y);
	vec3 rayDirection = normalize(rayPosition - ubo.position);

    return Ray(rayPosition, rayDirection);
}

void main() {
    Ray ray = createRay();


   
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(octree.nodes[0].END, 1.0f));
}
